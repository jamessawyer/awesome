课程来源：[Hussein Nasser](https://www.udemy.com/user/hussein-nasser-7/)

- https://www.udemy.com/course/database-engines-crash-course/

b站地址：

- https://www.bilibili.com/video/BV13q4y1i7hZ

课程梗概：
学习和理解 ACID 属性
数据库索引
数据库分区
数据库复制
数据库分片
数据库游标
并发控制（乐观、悲观）
生产数据库系统中的 B 树
数据库系统设计
数据库管理系统、数据库引擎和嵌入式数据库之间的区别
MyISAM、InnoDB、RocksDB、LevelDB 等数据库引擎
使用一个数据库引擎优于另一个的好处
使用 MySQL 切换数据库引擎
数据库安全
同态加密



课程章节内容：

1. 2-14： 事务，ACID，脏读，不可重复度，幻读，隔离等级
2. 15-17：索引存储方式，一种数据解耦，Row-Based(最常用) vs Column-Based（很少用，多用于aggregation时，比如计算sum()）
3. 18-28：索引
   1. 18-22: 索引的作用，执行效率分析方法， `explain & explain analyze` 的分析方法， Query Plan；索引扫描 & Index-Only扫描；Key索引和Non-Key索引（使用 `include` 方式，比如 `create index g_idx on students(grade) include (id)`, 将grade设置为索引，同时在索引中包含id数据）
   2. 23: 使用联合索引提升性能，当有多个索引时，数据库是如何去查询的，比如 `id-name` 索引，数据库只有对 `id + name` 或者 `id` 查询时使用索引，而单独查询 `name` 时不会使用索引
   3. 24：数据库存在索引时，**但真正查询时是否使用索引**，数据库会对存储数据进行异步的分析，获取一些统计数据信息，然后根据查询条件，使用最优的查询方式去查询。
   4. 25: 数据库的几种扫描方式： `seq table scan` & `index scan(包含index-only scan)` & postgres 特有的 `bitmap index scan`， 不同查询语句会导致不同的扫描方式
   5. 26：如何使用命令并行的创建索引，从而在生产环境下，创建索引时不影响数据的写入，可以使用 `concurrently` 命令 `create index concurrently g_idx on grades(grade);`
   6. 27: 布隆过滤器（`bloom filter`）的原理，布隆过滤器的作用，一般用于在查询数据库之前，对数据做检测，查看数据是否存在，比如注册时，验证用户名是否已经被注册
   7. 28：10亿条数据的表如何处理：先考虑数据库的设计是否合理，有必要上10亿条数据吗；水平分表查询（partitioning）；数据库分片（shard）；但是这种设计又会导致一些其它的问题，增加业务的复杂度
4. 29-37： BTree & B+Tree（B表示balanced）平衡树
   1. 29-30：简单介绍BTree & B+Tree，不使用索引的数据结构（BTree），而进行全表扫描的问题
   2. 31-33: BTree这种数据结构是如何存储索引的，为什么它能提升查询性能。原始BTree的限制：每个节点都是由 `key-value` 组成，而没有使用到的 `value` 会造成空间的浪费；区域查询（range-search）,比如查询 `age between 30 and 40`, 效率低下，每次都要从头开始查询
   3. 34-37: B+Tree的数据结构，节点只会存储key，只有叶子节点会存储 `key-value`, 节省空间；并且所有的叶子节点都通过链表的形式连接，因此对区域查询十分高效
5. 38-51: `partitioning` 分区的作用；水平分区&垂直分区；分区的类型；分区和分片(`sharding`)的区别；分区的优势和缺点
   1. 38-39: 分区的应用场景，对于大表分区的作用
   2. 40: 水平分区（几乎都是使用水平） vs 垂直分区（很少场景，比如有一列存储的是很大的blob对象，则可以采取垂直分区，将该列单独存在一张表中，这样可提升查询效率）
   3. 41: 分区类型（即分区依据）：by range: 按时间分，按id分; 离散类型分区：比如按照值分，比如北京商家的数据和上海的数据分开，按邮政编码分；按hash函数分（很少）
   4. 42: partitioning vs sharding, 分区分库的区别，partitioning一般是将大表拆分存储在相同的服务器中；sharding是将一个大表存储在不同的服务器上
   5. 43-47：实例：使用 docker + postgres 手动创建一个大表，然后通过命令行的方式创建分区并将分区attach到原表上，如何创建索引，explain分区查询
   6. 48-49: 分区的优缺点，提升单区查询效率，**热冷数据分区，将不常用的数据存储起来，优先保证热数据的查询**；缺点是更新rows，然后将其移动到更新后的分区比较慢，并且有可能失败；schema变更之后，处理起来比较麻烦
   7. 50-51: 总结 & 使用 nodejs作为示例，如何使用脚本进行分区，而不是手动执行命令去分区
6. 52-63: `sharding` 分片；一致性hash；水平分区和分片的区别；
   1. 52-53：介绍分片概念
   2. 54：一致性hash，用于决定存储那个服务器上的数据库，以及从那个服务器去读取数据，一致性hash的基本原理
   3. 55: 水平分表（partitioning）和分片（sharding）的区别: 水平分表是在**同一个服务器**上，将大表分成小表，表名不同；分片是将大表拆分到**不同服务器**上，表名一致
   4. 56-57: 如何使用docker+postgres制作一个镜像，然后生成的镜像生成3个容器来模拟3个服务器，分别存放相同的表去模拟sharding
   5. 58-59：实战🚀 使用express + pg + [hashring](https://github.com/serialx/hashring) (用于实现一致性hash) + crypto 实现一个短链接功能，将数据分别存储到3台不同服务器中的相同表中；如何使用一致性hash自动判断从那个服务器读取数据
   6. 60-62: sharding的优缺点，优点：可扩展性，内存占用量更小，可增强安全性，让某些用户访问特定shards；缺点：增加项目复杂度，分区事务问题，回滚问题，很难改变表的schema，联合查询问题
   7. 63: 什么时候使用sharding的讨论，尽可能不要使用sharding，不要过度工程化，sharding带来的问题有可能远比其带来的优点大，优先考虑分表或者副本（replicates），主写多副本读的方式

